#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  touch,          sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LEDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,            ,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           fork,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           L_lift,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           R_lift,        tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port7,           REDrive,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           clawArm,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*		NOTE:
Things marked with //FIX are things that are probably dependant on external
factors and need to change depending. Just make sure they're all right before
testing or stuff.
*/



//   __        __   __                          __          __        ___  __
//  / _` |    /  \ |__)  /\  |       \  /  /\  |__) |  /\  |__) |    |__  /__`
//  \__> |___ \__/ |__) /~~\ |___     \/  /~~\ |  \ | /~~\ |__) |___ |___ .__/
//

float kP_drive = 2; //0.8, 0.65, 0.7,0.75, 0.78, 0.93, 0.95, 5, 1.45, 1.06, 0.27, 0.2, 2, 1.6
float kP_drift = 0; //2,3
float kD = 15.6; //0.085, 0.085,0.07, 0.065, 0.06,0.057,0.052, 0.052, 0.05, 0.324, 0.03348,0.3575, 0.02, 15.7
float kI = 0.36; //0, 0.1, 0.2, 0.1, 0.03, 5, 0.32, 0.14, 0.6
float toMotor = 0;
float powerP = 0;
float powerI = 0;
float powerD = 0;

float headingAngle = 0;

//Conversions
float inches_per_tile = 24; //23.25, 22.25
float ticks_per_revolution = 392; //FIX This is for the high speed configuration only
float ticks_per_inch = ticks_per_revolution/(PI*4); //FIX 4" omni wheels
float ticks_per_tile = ticks_per_inch*inches_per_tile;

//moveStraight variables
float error;
float power;
float driftPower;
float targetTicks;
float prevError;
float gyroError;
float derivative;
float integral = 0;
float integral_active_zone = 40; //FIX idk man arbitrary, 130
float errorThreshold = 2; //errorThresholdInTicks=(ticks_per_inch)*(errorThresholdInInches) arbitrary

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"



//   __   __   ___              ___  __
//  |__) |__) |__      /\  |  |  |  /  \ |\ |
//  |    |  \ |___    /~~\ \__/  |  \__/ | \|
//

void pre_auton()
{
	slaveMotor(R_lift, L_lift);
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);
	SensorValue[gyro] = 0;
}



//    __       ___          __      ___  ___
//   /__` |   |__  |  |    |__)  /\  |  |__
//   .__/ |__ |___ |/\|    |  \ /~~\ |  |___
//

int motorSlewRate = 5; //20
float tempMotor = 0;
float motorReq = 0;


void assignPower (int motorIndex){ //REDrive is index 6, LEDrive is index 1
	tempMotor = motor[motorIndex];
	if (tempMotor != motorReq)
	{
		if (tempMotor < motorReq)
		{
			tempMotor = tempMotor +	motorSlewRate;
			if (tempMotor > motorReq)
			{
				tempMotor = motorReq;
			}
		}
		else
		{
			tempMotor = tempMotor -	motorSlewRate;
			if (tempMotor < motorReq)
			{
				tempMotor = motorReq;
			}
		}

		motor[motorIndex] = tempMotor;
	}
}

task slewRate()
{
	while (1)
	{
		assignPower(6); //REDrive is index 6
		assignPower(1); //LEDrive is index 1
		wait1Msec(15);
	}
}


//         __        ___     __  ___  __          __       ___
//   |\/| /  \ \  / |__     /__`  |  |__)  /\  | / _` |__|  |
//   |  | \__/  \/  |___    .__/  |  |  \ /~~\ | \__> |  |  |
//

void moveStraight(int direction, float tiles){
	targetTicks = tiles*ticks_per_tile;
	prevError = targetTicks;
	nMotorEncoder[LEDrive]=0;
	nMotorEncoder[REDrive]=0;
	error = targetTicks-((abs(nMotorEncoder[LEDrive])+abs(nMotorEncoder[REDrive]))/2);
	headingAngle = SensorValue[gyro]/10;
	float scaling = 127/targetTicks;
	integral = 0;
	clearTimer(T1);
	while((time1[T1]<2000)){ // && (error>errorThreshold)1500
		error = targetTicks-((abs(nMotorEncoder[LEDrive])+abs(nMotorEncoder[REDrive]))/2);
		gyroError = (SensorValue[gyro]/10)-headingAngle; //Error in degrees

		integral = integral + error;
		if(abs(error)>integral_active_zone){
			integral = 0;
		}
		if (abs(error) <= errorThreshold){
			integral = 0;
		}

		derivative = error - prevError;

		driftPower = gyroError * kP_drift;
		powerP = kP_drive*error*direction*scaling;
		powerI = kI*integral*direction*scaling;
		powerD = kD*derivative*direction*scaling;
		power = (powerP)+(powerI)+(powerD);

		toMotor = power;
		motorReq = toMotor;
		prevError = error;
		wait1Msec(25);
	}
	toMotor = 0;
	motorReq = toMotor;
}


//   __       ___            __   __
//  |  \  /\   |   /\  |    /  \ / _`
//  |__/ /~~\  |  /~~\ |___ \__/ \__>
//

task datalog(){
	while(1){
		datalogDataGroupStart();
		datalogAddValue( 0, error);
		datalogAddValue( 1, toMotor);
		datalogAddValue( 2, powerP);
		datalogAddValue( 3, powerI);
		datalogAddValue( 4, powerD);
		datalogAddValue( 5, tempMotor);
		datalogDataGroupEnd();
		wait1Msec(25);
	}
}

//            ___  __
//   /\  |  |  |  /  \
//  /~~\ \__/  |  \__/
//

task autonomous()
{
	startTask(slewRate);
	startTask(datalog);
	moveStraight(1,1);
	wait1Msec(500);
	moveStraight(-1,1);
	wait1Msec(500);
	stopTask(slewRate);
	stopTask(datalog);
}



//        __   ___  __      __   __       ___  __   __
//  |  | /__` |__  |__)    /  ` /  \ |\ |  |  |__) /  \ |
//  \__/ .__/ |___ |  \    \__, \__/ | \|  |  |  \ \__/ |___
//

task usercontrol()
{
	slaveMotor(R_lift, L_lift);
	int driveThreshold = 20;
	while (true)
	{
		while(1){
			if(abs(vexRT[Ch3])>driveThreshold){
				motor[LEDrive]=vexRT[Ch3];
				}	else {
				motor[LEDrive]=0;
			}
			if(abs(vexRT[Ch2])>driveThreshold){
				motor[REDrive]=vexRT[Ch2];
				}	else {
				motor[REDrive]=0;
			}

			if(vexRT[Btn7U]==1){
				motor[clawArm]=127;
			}
			else if(vexRT[Btn7D]==1){
				motor[clawArm]=-127;
			}
			else {
				motor[clawArm]=0;
			}

			if(vexRT[Btn5U]==1){
				motor[fork]=127;
			}
			else if(vexRT[Btn5D]==1){
				motor[fork]=-127;
			}
			else {
				motor[fork]=0;
			}

			if(vexRT[Btn6U]==1){
				motor[L_lift]=127;
			}
			else if(vexRT[Btn6D]==1){
				motor[L_lift]=-127;
			}
			else {
				motor[L_lift]=0;
			}

		}
	}
}
